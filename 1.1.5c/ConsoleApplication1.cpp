// ConsoleApplication1.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。
//
//没用c++的面向对象编程  (对象=结构体  方法=对结构体函数)
//其实用面对对象编程可能好定义一些
//VS编译器c语言居然可以中文  不该在建模搞首字母变量的   
#include <iostream>
#include <cmath>
#include <limits>
#include <opencv2/opencv.hpp>
#include "cvui.h"
//子弹序列改为后坐力拐点序列
extern const double PI = 3.14159265358979323846;
extern const int  X宽度 = 900;
extern const int  Y长度 = 900;
extern const double 游戏距离到屏幕距离放缩系数 = 1;
const double& FSXS = 游戏距离到屏幕距离放缩系数;

using namespace std::chrono;
using namespace std;
using namespace cv;

typedef struct 玩家技术 {//定义在最开始 后面有函数用到这个结构体
    double 简单压枪倍率;
    double 简单目标跟踪倍率;
    double 压枪方向熟练程度;
    double 压枪速度熟练程度;
    double 压枪时间熟练程度;
    double 跟枪速度熟练程度;
    double 跟枪方向熟练程度;
    double 反应力;
    double 跟枪等级;
}玩家技术;

typedef struct 屏幕偏差 {//目标点距离准星屏幕偏差
    double X_屏幕;
    double Y_屏幕;
}屏幕偏差;

typedef struct 屏幕拐点序列 {//记录了后坐力发生剧烈转折时子弹位置与时间或者子弹在不压枪情况下子弹位置和距离第一次开火时间  
    double 位置_X_屏幕 = { 0 };
    double 位置_Y_屏幕 = { 0 };
    double 开火时间_T = { 0 };
    double 速度_X_屏幕 = { 0 };//在这里用空间换时间  速度要重复计算  不如直接存起来
    double 速度_Y_屏幕 = { 0 };
    double 加速度_X_屏幕 = { 0 };
    double 加速度_Y_屏幕 = { 0 };
}屏幕拐点序列;//这里直接输入所有子弹的位置与时间也可以,直接将后坐力拆成超多拐点的折现  子弹XY坐标也可以做成后坐力偏差类型  建议数组 拐点[0]={0,0,0}

typedef struct 实际拐点序列 {//记录了游戏内的  实际  坐标的拐点序列
    double 位置_X_实际 = { 0 };
    double 位置_Y_实际 = { 0 };
    double 位置_Z_实际 = { 10 };
    double 转折时间_T = { 0 };
    double 速度_X_实际 = { 0 };//在这里用空间换时间  速度要重复计算  不如直接存起来
    double 速度_Y_实际 = { 0 };
    double 速度_Z_实际 = { 0 };
    double 加速度_X_实际 = { 0 };
    double 加速度_Y_实际 = { 0 };
    double 加速度_Z_实际 = { 0 };
}实际拐点序列;

typedef struct 目标大小 {//目标简单判定框大小 三维立方体判定框在屏幕存在斜线   不可以使用一重积分方法   复杂模型可以由多个框组成  这里暂时使用单个方框
    double X_实际;//方形判断框的宽 
    double Y_实际;//方形判断框的长
}目标大小;

typedef struct 目标大小序列 {//目标简单判定框大小随时间变化序列    复杂模型可以由多个框组成  这里暂时使用单个方框
    double X_实际 = { 10 };//方形判断框的宽 
    double Y_实际 = { 10 };//方形判断框的长
    double 变形时间T = { 0 };
}目标大小序列;

typedef struct 目标中心实际位置 {//目标位置距离原点偏差
    double X_实际;//目标位置距离原点偏差x
    double Y_实际;//目标位置距离原点偏差y
    double Z_实际;//目标位置距离原点偏差z
}目标中心实际位置;

typedef struct 边框实际位置 {//目标在屏幕实际位置坐标
    double 左下角_X_屏幕;
    double 左下角_Y_屏幕;
    double 右上角_X_屏幕;
    double 右上角_Y_屏幕;
}边框实际位置;

typedef 屏幕偏差(*后坐力函数类型)(double);//下方所有类型定义都为函数指针

typedef double(*概率密度函数类型)(double, double, double);

typedef double(*子弹衰减函数类型)(double);

typedef 目标大小(*目标大小函数类型)(double);

typedef 目标中心实际位置(*目标移动函数类型)(double, 目标中心实际位置);

typedef struct 目标总体 {//说实话 一些函数已经完全被序列替代了
    目标大小 目标游戏内起始大小;
    目标大小序列 目标游戏内大小序列[10];
    目标大小函数类型 目标游戏内大小函数指针;
    目标中心实际位置 目标游戏内起始位置;
    实际拐点序列 移动序列[100];
    目标移动函数类型 目标游戏内移动函数指针;
    int 目标血量;
    边框实际位置 目标在屏幕位置;
}目标总体;

typedef struct 枪械 {//枪械的一个集合 包含许多基本要素
    int 武器伤害;//伤害常量
    float 武器射速;//射速
    float 耗光时间;//弹夹耗光时间
    float 放大倍率;//放大倍率
    float 换弹时间;//换弹时间
    float 持枪移动速度;//持枪时移动速度
    float 射击移动速度;//射击时移动速度
    后坐力函数类型 后坐力函数指针;
    屏幕拐点序列 枪械子弹序列[100];//预设100发子弹的后座位置或者关键拐点位置
    子弹衰减函数类型 子弹衰减函数指针;
    double 子弹散布参数;
    概率密度函数类型 子弹概率密度函数指针;
    概率密度函数类型 子弹概率累计函数指针;
}枪械;

void 屏幕拐点位置_转速度函数(屏幕拐点序列* 位置拐点) {//对于只有位置的拐点序列进行一阶近似  添加其速度
    int 数组指针;
    for (数组指针 = 0; 数组指针 < 99; 数组指针++) {
        if (位置拐点[数组指针 + 1].开火时间_T == 0) {//从数组1开始搜索  因为末尾后没定义的数组默认为0  所以如果循环到末尾 结束 下同
            break;
        }
        double 时间差 = 位置拐点[数组指针 + 1].开火时间_T - 位置拐点[数组指针].开火时间_T;//避免重复计算 下同
        位置拐点[数组指针].速度_X_屏幕 = (位置拐点[数组指针 + 1].位置_X_屏幕 - 位置拐点[数组指针].位置_X_屏幕) / 时间差;
        位置拐点[数组指针].速度_Y_屏幕 = (位置拐点[数组指针 + 1].位置_Y_屏幕 - 位置拐点[数组指针].位置_Y_屏幕) / 时间差;
        位置拐点[数组指针].加速度_X_屏幕 = 0;
        位置拐点[数组指针].加速度_Y_屏幕 = 0;
    }
}

void 屏幕拐点速度_转位置函数(屏幕拐点序列* 速度拐点) {//对于没有位置拐点序列进行简单积分  添加其偏差
    int 数组指针;
    for (数组指针 = 0; 数组指针 < 99; 数组指针++) {
        if (速度拐点[数组指针 + 1].开火时间_T == 0) {
            break;
        }
        double 时间差 = 速度拐点[数组指针 + 1].开火时间_T - 速度拐点[数组指针].开火时间_T;
        速度拐点[数组指针 + 1].位置_X_屏幕 = 速度拐点[数组指针].位置_X_屏幕 + 速度拐点[数组指针].速度_X_屏幕 * 时间差 + (速度拐点[数组指针].加速度_X_屏幕 / 2) * 时间差 * 时间差;
        速度拐点[数组指针 + 1].位置_Y_屏幕 = 速度拐点[数组指针].位置_Y_屏幕 + 速度拐点[数组指针].速度_Y_屏幕 * 时间差 + (速度拐点[数组指针].加速度_Y_屏幕 / 2) * 时间差 * 时间差;
    }
}

void 实际拐点位置_转速度函数(实际拐点序列* 位置拐点) {//对于只有位置的拐点序列进行一阶近似  添加其速度
    int 数组指针;
    for (数组指针 = 0; 数组指针 < 99; 数组指针++) {
        if (位置拐点[数组指针 + 1].转折时间_T == 0) {
            break;
        }
        double 时间差 = 位置拐点[数组指针 + 1].转折时间_T - 位置拐点[数组指针].转折时间_T;
        位置拐点[数组指针].速度_X_实际 = (位置拐点[数组指针 + 1].位置_X_实际 - 位置拐点[数组指针].位置_X_实际) / 时间差;
        位置拐点[数组指针].速度_Y_实际 = (位置拐点[数组指针 + 1].位置_Y_实际 - 位置拐点[数组指针].位置_Y_实际) / 时间差;
        位置拐点[数组指针].速度_Z_实际 = (位置拐点[数组指针 + 1].位置_Z_实际 - 位置拐点[数组指针].位置_Z_实际) / 时间差;
        位置拐点[数组指针].加速度_X_实际 = 0;
        位置拐点[数组指针].加速度_Y_实际 = 0;
        位置拐点[数组指针].加速度_Y_实际 = 0;
    }
}

void 实际拐点速度_转位置函数(实际拐点序列* 速度拐点) {//对于没有位置拐点序列进行简单积分  添加其位置
    int 数组指针;
    for (数组指针 = 0; 数组指针 < 99; 数组指针++) {
        if (速度拐点[数组指针 + 1].转折时间_T == 0) {
            break;
        }
        double 时间差 = 速度拐点[数组指针 + 1].转折时间_T - 速度拐点[数组指针].转折时间_T;
        速度拐点[数组指针 + 1].位置_X_实际 = 速度拐点[数组指针].位置_X_实际 + 速度拐点[数组指针].速度_X_实际 * 时间差 + (速度拐点[数组指针].加速度_X_实际 / 2) * 时间差 * 时间差;
        速度拐点[数组指针 + 1].位置_Y_实际 = 速度拐点[数组指针].位置_Y_实际 + 速度拐点[数组指针].速度_Y_实际 * 时间差 + (速度拐点[数组指针].加速度_Y_实际 / 2) * 时间差 * 时间差;
        速度拐点[数组指针 + 1].位置_Z_实际 = 速度拐点[数组指针].位置_Z_实际 + 速度拐点[数组指针].速度_Z_实际 * 时间差 + (速度拐点[数组指针].加速度_Z_实际 / 2) * 时间差 * 时间差;
    }
}

屏幕偏差 屏幕拐点型_转屏幕偏差函数(屏幕拐点序列* 屏幕拐点, double 时间变量) {//输入时间和拐点序列  输出在T时刻的屏幕偏差
    屏幕偏差 后坐力偏差临时变量 = { 0,0 };
    int 数组指针 = 0;
    while (屏幕拐点[数组指针 + 1].开火时间_T <= 时间变量) {//寻找一个开火时间[i]<时间<开火时间[i+1]的位置 下同
        数组指针++;
        if (数组指针 >= 100) {//找遍所以未找到对应  强制结束  下同
            return 后坐力偏差临时变量;
        }
    }
    double 时间差 = 时间变量 - 屏幕拐点[数组指针].开火时间_T;
    后坐力偏差临时变量.X_屏幕 = 屏幕拐点[数组指针].位置_X_屏幕 + 屏幕拐点[数组指针].速度_X_屏幕 * (时间差) + 屏幕拐点[数组指针].加速度_X_屏幕 * (时间差) * (时间差) / 2;
    后坐力偏差临时变量.Y_屏幕 = 屏幕拐点[数组指针].位置_Y_屏幕 + 屏幕拐点[数组指针].速度_Y_屏幕 * (时间差) + 屏幕拐点[数组指针].加速度_Y_屏幕 * (时间差) * (时间差) / 2;
    return 后坐力偏差临时变量;
}

屏幕偏差 实际拐点型_转屏幕偏差函数(实际拐点序列* 实际拐点, double 时间变量) {//输入时间和拐点序列  输出在T时刻的屏幕偏差
    目标中心实际位置 目标位置临时变量 = { 0,0,0 };
    屏幕偏差 后坐力偏差临时变量 = { 0,0 };
    int 数组指针 = 0;
    while (实际拐点[数组指针 + 1].转折时间_T <= 时间变量) {
        数组指针++;
        if (数组指针 >= 100) {
            return 后坐力偏差临时变量;
        }
    }
    double 时间差 = 时间变量 - 实际拐点[数组指针].转折时间_T;
    目标位置临时变量.X_实际 = 实际拐点[数组指针].位置_X_实际 + 实际拐点[数组指针].速度_X_实际 * (时间差) + 实际拐点[数组指针].加速度_X_实际 * (时间差) * (时间差) / 2;
    目标位置临时变量.Y_实际 = 实际拐点[数组指针].位置_Y_实际 + 实际拐点[数组指针].速度_Y_实际 * (时间差) + 实际拐点[数组指针].加速度_Y_实际 * (时间差) * (时间差) / 2;
    目标位置临时变量.Z_实际 = 实际拐点[数组指针].位置_Z_实际 + 实际拐点[数组指针].速度_Z_实际 * (时间差) + 实际拐点[数组指针].加速度_Z_实际 * (时间差) * (时间差) / 2;
    后坐力偏差临时变量.X_屏幕 = 目标位置临时变量.X_实际 * 游戏距离到屏幕距离放缩系数 / 目标位置临时变量.Z_实际;
    后坐力偏差临时变量.Y_屏幕 = 目标位置临时变量.Y_实际 * 游戏距离到屏幕距离放缩系数 / 目标位置临时变量.Z_实际;
    return 后坐力偏差临时变量;
}

屏幕偏差 屏幕拐点型_转屏幕速度偏差函数(屏幕拐点序列* 屏幕拐点, double 时间变量) {//输入时间和拐点序列  输出在T时刻的屏幕偏差的速度
    屏幕偏差 后坐力速度偏差临时变量 = { 0,0 };
    int 数组指针 = 0;
    while (屏幕拐点[数组指针 + 1].开火时间_T <= 时间变量) {
        数组指针++;
        if (数组指针 >= 999) {
            return 后坐力速度偏差临时变量;
        }
    }
    double 时间差 = 时间变量 - 屏幕拐点[数组指针].开火时间_T;
    后坐力速度偏差临时变量.X_屏幕 = 屏幕拐点[数组指针].速度_X_屏幕 + 屏幕拐点[数组指针].加速度_X_屏幕 * (时间差);
    后坐力速度偏差临时变量.Y_屏幕 = 屏幕拐点[数组指针].速度_Y_屏幕 + 屏幕拐点[数组指针].加速度_Y_屏幕 * (时间差);
    return 后坐力速度偏差临时变量;
}

屏幕偏差 实际拐点型_转屏幕速度偏差函数(实际拐点序列* 实际拐点, double 时间变量) {
    目标中心实际位置 目标位置临时变量 = { 0,0,0 };
    屏幕偏差 后坐力速度偏差临时变量 = { 0,0 };
    int 数组指针 = 0;
    while (实际拐点[数组指针 + 1].转折时间_T <= 时间变量) {
        数组指针++;
        if (数组指针 >= 100) {
            return 后坐力速度偏差临时变量;
        }
    }
    //设X实际位移函数  (X位置+X速度*时间+X加速度*时间^2/2)
    //设Z实际位移函数  (Z位置+Z速度*时间+Z加速度*时间^2/2)
    //屏幕位置X函数为  (X实际位移)/(Z实际位移)*放缩系数
    //所以屏幕速度X函数为 上面函数对时间求导  (X实际位移导函数*Z实际位移-X实际位移*Z实际位移导函数)/(Z实际位移)^2*放缩系数
    //((X速度*Z位置-X位置*Z速度+(X加速度*Z位置-X位置*Z加速度)*时间+((X加速度*Z速度-X速度*Z加速度)/2)*时间^2 )*放缩系数)/Z实际位移^2 
    //详细解释见文档附录
    double 时间差 = 时间变量 - 实际拐点[数组指针].转折时间_T;
    目标位置临时变量.Z_实际 = 实际拐点[数组指针].位置_Z_实际 + 实际拐点[数组指针].速度_Z_实际 * (时间差)+实际拐点[数组指针].加速度_Z_实际 * (时间差) * (时间差) / 2;
    后坐力速度偏差临时变量.X_屏幕 = ((实际拐点[数组指针].速度_X_实际 * 实际拐点[数组指针].位置_Z_实际 - 实际拐点[数组指针].速度_Z_实际 * 实际拐点[数组指针].位置_X_实际 + (实际拐点[数组指针].加速度_X_实际 * 实际拐点[数组指针].位置_Z_实际 - 实际拐点[数组指针].位置_X_实际 * 实际拐点[数组指针].加速度_Z_实际) * 时间差 + ((实际拐点[数组指针].加速度_X_实际 * 实际拐点[数组指针].速度_Z_实际 - 实际拐点[数组指针].速度_X_实际 * 实际拐点[数组指针].加速度_Z_实际) / 2) * 时间差 * 时间差) * 游戏距离到屏幕距离放缩系数) / (目标位置临时变量.Z_实际 * 目标位置临时变量.Z_实际);
    后坐力速度偏差临时变量.Y_屏幕 = ((实际拐点[数组指针].速度_Y_实际 * 实际拐点[数组指针].位置_Z_实际 - 实际拐点[数组指针].速度_Z_实际 * 实际拐点[数组指针].位置_Y_实际 + (实际拐点[数组指针].加速度_Y_实际 * 实际拐点[数组指针].位置_Z_实际 - 实际拐点[数组指针].位置_Y_实际 * 实际拐点[数组指针].加速度_Z_实际) * 时间差 + ((实际拐点[数组指针].加速度_Y_实际 * 实际拐点[数组指针].速度_Z_实际 - 实际拐点[数组指针].速度_Y_实际 * 实际拐点[数组指针].加速度_Z_实际) / 2) * 时间差 * 时间差) * 游戏距离到屏幕距离放缩系数) / (目标位置临时变量.Z_实际 * 目标位置临时变量.Z_实际);
    return 后坐力速度偏差临时变量;
}

目标中心实际位置 实际拐点型_转实际位置函数(实际拐点序列* 实际拐点, double 时间变量) {
    目标中心实际位置 目标位置临时变量 = { 0,0,0 };
    int 数组指针 = 0;
    while (实际拐点[数组指针 + 1].转折时间_T <= 时间变量) {
        数组指针++;
        if (数组指针 >= 100) {
            return 目标位置临时变量;
        }
    }
    double 时间差 = 时间变量 - 实际拐点[数组指针].转折时间_T;
    目标位置临时变量.X_实际 = 实际拐点[数组指针].位置_X_实际 + 实际拐点[数组指针].速度_X_实际 * (时间差)+实际拐点[数组指针].加速度_X_实际 * (时间差) * (时间差) / 2;
    目标位置临时变量.Y_实际 = 实际拐点[数组指针].位置_Y_实际 + 实际拐点[数组指针].速度_Y_实际 * (时间差)+实际拐点[数组指针].加速度_Y_实际 * (时间差) * (时间差) / 2;
    目标位置临时变量.Z_实际 = 实际拐点[数组指针].位置_Z_实际 + 实际拐点[数组指针].速度_Z_实际 * (时间差)+实际拐点[数组指针].加速度_Z_实际 * (时间差) * (时间差) / 2;
    return 目标位置临时变量;
}

double 正态分布随机数(double 方差, double 期望)//见Box-Muller算法
{
    const double 双浮点最小值 = std::numeric_limits<double>::min();
    double 正态分布随机数;
    double 均匀分布随机数1, 均匀分布随机数2;
    do
    {
        均匀分布随机数1 = rand() * (1.0 / RAND_MAX);
        均匀分布随机数2 = rand() * (1.0 / RAND_MAX);
    } while (均匀分布随机数1 <= 双浮点最小值);
    正态分布随机数 = sqrt(-2.0 * log(均匀分布随机数1)) * cos(2 * PI * 均匀分布随机数2);
    return 正态分布随机数 * 方差 + 期望;
};

double 子弹散布正态分布概率密度函数(double X, double Y,double 方差倒数) {//正态分布概率密度方差倒数   描述准星扩散大小   值越大越集中   (为什么不用方差  方差数小时 1/方差  误差会被放大)
    double 概率 = 0;//子弹击中X,Y的概率
    概率=(1 * 方差倒数 * 方差倒数) / (PI * 2) * exp(-((X * X + Y * Y) * 方差倒数 * 方差倒数) / 2);
    return 概率;
}

double 子弹散布均匀分布概率密度(double X, double Y, double 边界) {//子弹散布累计概率密度 既子弹击中属于(-无穷,X)(-无穷,Y)大片区域的概率 现已经废弃
    double 概率 = 0;//子弹击中X,Y的概率
    if (X > (-1 * 边界) && X<边界 && Y>(-1 * 边界) && Y < 边界){
        概率 = 1 / (边界 * 边界);
    }
    return 概率;
}

double 子弹散布正态分布累计概率密度(double X, double Y,double 方差倒数) {//子弹散布累计概率密度 既子弹击中属于(-无穷,X)(-无穷,Y)大片区域的概率
    double 概率 = 0;//子弹击中X,Y的概率
    概率 = (erf(X * 方差倒数 / sqrt(2)) + 1) / 2 * (erf(Y * 方差倒数 / sqrt(2)) + 1) / 2;//我是sb  这么简单的函数找了好久没找到还想自己写
    return 概率;
}

double 子弹散布均匀分布累计概率密度(double X, double Y ,double 边界) {//子弹散布累计概率密度 既子弹击中属于(-无穷,X)(-无穷,Y)大片区域的概率  现已经废弃
    double 概率 = 0;//子弹击中X,Y的概率
    if (X > 边界 && Y > 边界) {
        概率 = 1;
    }
    else if (Y > 边界&& X > -1 * 边界) {
        概率 = (X + 边界) / (2 * 边界);
    }
    else if (X > 边界 && Y > -1 * 边界) {
        概率 = (Y + 边界) / (2 * 边界);
    }
    else if (X > -1 * 边界 && Y > -1 * 边界) {
        概率 = (X + 边界) * (Y + 边界) / (4 * 边界);;
    }
    else {
        概率 = 0;
    }
    return 概率;
}

屏幕偏差 p2020后坐力函数(double time) {//现在已经被拐点序列代替
    屏幕偏差 临时变量;
    临时变量.X_屏幕 = time;
    临时变量.Y_屏幕 = time;
    return 临时变量;
}

double p2020子弹衰减(double 目标位置Z) {//子弹衰减函数   (瞎设的数值)
    double 衰减倍率;
    if (目标位置Z <= 20) {//如果与目标距离小于20伤害不变
        衰减倍率 = 1;
    }
    else if (目标位置Z <= 50) {//如果与目标距离大于20 小于50伤害乘0.7
        衰减倍率 = 0.7;
    }
    else {//如果与目标距离大于50伤害乘0.5
        衰减倍率 = 0.5;
    }
    return 衰减倍率;
}

目标中心实际位置 目标移动(double 时间, 目标中心实际位置 目标a) {//目标移动函数  现已经废弃  被拐点序列替代
    目标a.X_实际 = 目标a.X_实际 + 时间;
    目标a.Y_实际 = 目标a.Y_实际 + 时间 / 5;
    目标a.Z_实际 = 目标a.Z_实际 + 时间;
    return 目标a;
}

目标大小 目标大小变动(double 时间) {//现已经废弃  被拐点序列替代
    目标大小 临时变量;
    临时变量.X_实际 = 10;
    临时变量.Y_实际 = 20;
    return 临时变量;
}

void 压枪函数(玩家技术 玩家技术实体,屏幕拐点序列* 后坐力拐点, 屏幕拐点序列* 压枪拐点) {//详细解释见文档
    int i;
    int j=1;
    double 压枪结束到拐点速度X_屏幕;
    double 压枪结束到拐点速度Y_屏幕;
    double 压枪结束到拐点时间间隔;
    double 速度误差;
    double 方向误差;
    double 时间误差;
    for (i = 0; i < 100; i++) {//遍历后坐力序列
        if (后坐力拐点[i + j].开火时间_T == 0) {//后坐力序列到达尽头  强制结束
            break;
        }
        if (后坐力拐点[i + j].开火时间_T > 压枪拐点[i].开火时间_T) {
            压枪结束到拐点时间间隔 = 后坐力拐点[i + j].开火时间_T - 压枪拐点[i].开火时间_T;
            压枪结束到拐点速度X_屏幕 = (后坐力拐点[i + j].位置_X_屏幕 - 压枪拐点[i].位置_X_屏幕) / 压枪结束到拐点时间间隔;
            压枪结束到拐点速度Y_屏幕 = (后坐力拐点[i + j].位置_Y_屏幕 - 压枪拐点[i].位置_Y_屏幕) / 压枪结束到拐点时间间隔;
            速度误差 = 正态分布随机数((double)(1 / 玩家技术实体.压枪速度熟练程度), 0);
            方向误差 = 正态分布随机数((double)(1 / 玩家技术实体.压枪方向熟练程度), 0);
            时间误差 = 正态分布随机数((double)(1 / 玩家技术实体.压枪时间熟练程度), 0);
            压枪拐点[i].速度_X_屏幕 = (压枪结束到拐点速度X_屏幕 * cos(PI * 方向误差) - 压枪结束到拐点速度Y_屏幕 * sin(PI * 方向误差)) * (1 + 速度误差);
            压枪拐点[i].速度_Y_屏幕 = (压枪结束到拐点速度Y_屏幕 * cos(PI * 方向误差) + 压枪结束到拐点速度X_屏幕 * sin(PI * 方向误差)) * (1 + 速度误差);
            压枪拐点[i + 1].位置_X_屏幕 = 压枪拐点[i].位置_X_屏幕 + 压枪拐点[i].速度_X_屏幕 * (压枪结束到拐点时间间隔 * (1 + 时间误差));
            压枪拐点[i + 1].位置_Y_屏幕 = 压枪拐点[i].位置_Y_屏幕 + 压枪拐点[i].速度_Y_屏幕 * (压枪结束到拐点时间间隔 * (1 + 时间误差));
            压枪拐点[i + 1].开火时间_T = 压枪拐点[i].开火时间_T + (压枪结束到拐点时间间隔 * (1 + 时间误差));
            压枪拐点[i].加速度_X_屏幕 = 0;
            压枪拐点[i].加速度_Y_屏幕 = 0;
        }
        else {
            j ++;
            i --;
        }
    }
};

void 跟枪函数(屏幕拐点序列* 后坐力拐点,屏幕拐点序列* 压枪拐点,实际拐点序列* 目标移动, 玩家技术 玩家技术实体, 屏幕拐点序列* 跟枪序列) {//详细解释见文档
    double 前速度累计量_X屏幕=0;
    double 前速度累计量_Y屏幕=0;
    屏幕偏差 临时偏差;
    屏幕偏差 临时速度偏差;
    double 速度误差;
    double 方向误差;
    double 一阶跟枪类型能力;
    double 二阶跟枪类型能力;
    int 数组指针;
    屏幕偏差 后坐力屏幕偏差;
    屏幕偏差 压枪屏幕偏差;
    屏幕偏差 目标运动屏幕偏差;
    屏幕偏差 后坐力屏幕速度偏差;
    屏幕偏差 压枪屏幕速度偏差;
    屏幕偏差 目标运动屏幕速度偏差;
    跟枪序列[1].开火时间_T = 玩家技术实体.反应力;
    if (玩家技术实体.跟枪等级 < 1) {
        一阶跟枪类型能力 = 玩家技术实体.跟枪等级;
        二阶跟枪类型能力 = 0;
    }
    else {
        一阶跟枪类型能力 = 1;
        二阶跟枪类型能力 = 玩家技术实体.跟枪等级;//玩家技术实体.跟枪等级最大为2
    }
    for (数组指针 = 1; 数组指针 < 300; 数组指针++) {//1阶跟枪
        速度误差 = 正态分布随机数((double)(1 / 玩家技术实体.跟枪速度熟练程度), 0);
        方向误差 = 正态分布随机数((double)(1 / 玩家技术实体.跟枪方向熟练程度), 0);

        后坐力屏幕偏差 = 屏幕拐点型_转屏幕偏差函数(后坐力拐点, 数组指针 * 玩家技术实体.反应力);
        压枪屏幕偏差 = 屏幕拐点型_转屏幕偏差函数(压枪拐点, 数组指针 * 玩家技术实体.反应力);
        目标运动屏幕偏差 = 实际拐点型_转屏幕偏差函数(目标移动, 数组指针 * 玩家技术实体.反应力);
        临时偏差.X_屏幕 = 压枪屏幕偏差.X_屏幕 - 后坐力屏幕偏差.X_屏幕 + 目标运动屏幕偏差.X_屏幕 - 跟枪序列[数组指针].位置_X_屏幕;
        临时偏差.Y_屏幕 = 压枪屏幕偏差.Y_屏幕 - 后坐力屏幕偏差.Y_屏幕 + 目标运动屏幕偏差.Y_屏幕 - 跟枪序列[数组指针].位置_Y_屏幕;
        
        后坐力屏幕速度偏差 = 屏幕拐点型_转屏幕速度偏差函数(后坐力拐点, 数组指针 * 玩家技术实体.反应力);
        压枪屏幕速度偏差 = 屏幕拐点型_转屏幕速度偏差函数(压枪拐点, 数组指针 * 玩家技术实体.反应力);
        目标运动屏幕速度偏差 = 实际拐点型_转屏幕速度偏差函数(目标移动, 数组指针 * 玩家技术实体.反应力);
        临时速度偏差.X_屏幕 = 压枪屏幕速度偏差.X_屏幕 - 后坐力屏幕速度偏差.X_屏幕 + 目标运动屏幕速度偏差.X_屏幕;
        临时速度偏差.Y_屏幕 = 压枪屏幕速度偏差.Y_屏幕 - 后坐力屏幕速度偏差.Y_屏幕 + 目标运动屏幕速度偏差.Y_屏幕;

        跟枪序列[数组指针].速度_X_屏幕 = ((临时偏差.X_屏幕 / 玩家技术实体.反应力 + 临时速度偏差.X_屏幕 * 一阶跟枪类型能力) * cos(PI * 方向误差) - (临时偏差.Y_屏幕 / 玩家技术实体.反应力 + 临时速度偏差.Y_屏幕 * 一阶跟枪类型能力) * sin(PI * 方向误差)) * (1 + 速度误差);
        跟枪序列[数组指针].速度_Y_屏幕 = ((临时偏差.Y_屏幕 / 玩家技术实体.反应力 + 临时速度偏差.Y_屏幕 * 一阶跟枪类型能力) * cos(PI * 方向误差) + (临时偏差.X_屏幕 / 玩家技术实体.反应力 + 临时速度偏差.X_屏幕 * 一阶跟枪类型能力) * sin(PI * 方向误差)) * (1 + 速度误差);

        跟枪序列[数组指针].加速度_X_屏幕 = 0;//先不急写这个
        跟枪序列[数组指针].加速度_Y_屏幕 = 0;

        跟枪序列[数组指针 + 1].开火时间_T = (数组指针 + 1) * 玩家技术实体.反应力;
        跟枪序列[数组指针 + 1].位置_X_屏幕 = 跟枪序列[数组指针].位置_X_屏幕+跟枪序列[数组指针].速度_X_屏幕 * (玩家技术实体.反应力) + (跟枪序列[数组指针].加速度_X_屏幕 / 2) * (玩家技术实体.反应力) * (玩家技术实体.反应力);
        跟枪序列[数组指针 + 1].位置_Y_屏幕 = 跟枪序列[数组指针].位置_Y_屏幕+跟枪序列[数组指针].速度_Y_屏幕 * (玩家技术实体.反应力) + (跟枪序列[数组指针].加速度_Y_屏幕 / 2) * (玩家技术实体.反应力) * (玩家技术实体.反应力);
    }
};

边框实际位置 实际位置函数(屏幕拐点序列* 后坐力拐点, 屏幕拐点序列* 压枪拐点, 实际拐点序列* 目标移动, 屏幕拐点序列* 跟枪拐点, 目标大小序列* 目标大小实体,double 时间变量) {//这个是重载函数  就是名字一样但参数不一样的函数叫 重载
    边框实际位置 临时变量={0,0,0,0};//
    目标大小 目标大小T时刻位置={10,10};
    int 数组指针 = 0;
    while (目标大小实体[数组指针 + 1].变形时间T <= 时间变量) {
        数组指针++;
        if (数组指针 >= 100) {
            break;
        }
    }
    屏幕偏差 后坐力偏差 = 屏幕拐点型_转屏幕偏差函数(后坐力拐点, 时间变量);
    屏幕偏差 压枪偏差 = 屏幕拐点型_转屏幕偏差函数(压枪拐点, 时间变量);
    目标中心实际位置 目标移动位置 = 实际拐点型_转实际位置函数(目标移动, 时间变量);
    屏幕偏差 跟枪偏差 = 屏幕拐点型_转屏幕偏差函数(跟枪拐点, 时间变量);
    if (目标移动位置.Z_实际 == 0) {//目标与玩家z轴位置为0 即完全贴合 这是不可能的 报错并返回
        return 临时变量;
    }
    目标大小T时刻位置.X_实际 = 目标大小实体[数组指针].X_实际;
    目标大小T时刻位置.Y_实际 = 目标大小实体[数组指针].Y_实际;
    临时变量.左下角_X_屏幕 = (目标移动位置.X_实际 - 目标大小T时刻位置.X_实际 / 2) * 游戏距离到屏幕距离放缩系数 / (目标移动位置.Z_实际) - 后坐力偏差.X_屏幕 + 压枪偏差.X_屏幕- 跟枪偏差.X_屏幕;
    临时变量.左下角_Y_屏幕 = (目标移动位置.Y_实际 - 目标大小T时刻位置.Y_实际 / 2) * 游戏距离到屏幕距离放缩系数 / (目标移动位置.Z_实际) - 后坐力偏差.Y_屏幕 + 压枪偏差.Y_屏幕- 跟枪偏差.Y_屏幕;
    临时变量.右上角_X_屏幕 = (目标移动位置.X_实际 + 目标大小T时刻位置.X_实际 / 2) * 游戏距离到屏幕距离放缩系数 / (目标移动位置.Z_实际) - 后坐力偏差.X_屏幕 + 压枪偏差.X_屏幕- 跟枪偏差.X_屏幕;
    临时变量.右上角_Y_屏幕 = (目标移动位置.Y_实际 + 目标大小T时刻位置.Y_实际 / 2) * 游戏距离到屏幕距离放缩系数 / (目标移动位置.Z_实际) - 后坐力偏差.Y_屏幕 + 压枪偏差.Y_屏幕- 跟枪偏差.Y_屏幕;
    return 临时变量;
};

边框实际位置 实际位置函数(目标中心实际位置 目标起始位置, 目标移动函数类型 目标移动函数指针, 目标大小函数类型 目标大小函数指针, 后坐力函数类型 后坐力函数指针, double 时间) {//老函数 
    边框实际位置 临时变量;
    目标大小 目标大小TIME时刻位置 = 目标大小函数指针(时间);
    目标中心实际位置 目标移动位置 = 目标移动函数指针(时间, 目标起始位置);
    屏幕偏差 偏差变量 = 后坐力函数指针(时间);
    临时变量.左下角_X_屏幕 = (目标移动位置.X_实际 - 目标大小TIME时刻位置.X_实际 / 2) * 游戏距离到屏幕距离放缩系数 / (目标移动位置.Z_实际) - 偏差变量.X_屏幕;
    临时变量.左下角_Y_屏幕 = (目标移动位置.Y_实际 - 目标大小TIME时刻位置.Y_实际 / 2) * 游戏距离到屏幕距离放缩系数 / (目标移动位置.Z_实际) - 偏差变量.Y_屏幕;
    临时变量.右上角_X_屏幕 = (目标移动位置.X_实际 + 目标大小TIME时刻位置.X_实际 / 2) * 游戏距离到屏幕距离放缩系数 / (目标移动位置.Z_实际) - 偏差变量.X_屏幕;
    临时变量.右上角_Y_屏幕 = (目标移动位置.Y_实际 + 目标大小TIME时刻位置.Y_实际 / 2) * 游戏距离到屏幕距离放缩系数 / (目标移动位置.Z_实际) - 偏差变量.Y_屏幕;
    return 临时变量;
};

double 简单模型累计概率形(枪械 枪械实体, double (累计概率函数指针)(double, double, double)) {//0.8版本的简单模型
    double 临时伤害总和变量 = 0;
    double 时间变量 = 0;
    屏幕偏差 后坐力偏差临时变量;
    int 循环变量;
    for (循环变量 = 0; 循环变量 < 1000; 循环变量++) {
        时间变量 = (double)循环变量 / 1000;
        后坐力偏差临时变量=p2020后坐力函数(时间变量);//后坐力函数最后会进人枪械集合 作为其中一个元素
        临时伤害总和变量 = 临时伤害总和变量 + (累计概率函数指针(后坐力偏差临时变量.X_屏幕 + 0.5, 后坐力偏差临时变量.Y_屏幕 + 0.5, 1) - 累计概率函数指针(后坐力偏差临时变量.X_屏幕 + 0.5, 后坐力偏差临时变量.Y_屏幕 - 0.5, 1) - 累计概率函数指针(后坐力偏差临时变量.X_屏幕 - 0.5, 后坐力偏差临时变量.Y_屏幕 + 0.5, 1) + 累计概率函数指针(后坐力偏差临时变量.X_屏幕 - 0.5, 后坐力偏差临时变量.Y_屏幕 - 0.5, 1))/1000;
        printf("总伤害 %lf 准星X %lf 准星Y %lf 时间 %lf\n", 临时伤害总和变量, 后坐力偏差临时变量.X_屏幕, 后坐力偏差临时变量.Y_屏幕, 时间变量);
    }
    临时伤害总和变量 = 临时伤害总和变量 * 枪械实体.武器伤害 * 枪械实体.武器射速;
    return 临时伤害总和变量;
};

double 简单模型概率密度形(枪械 枪械实体, double (概率密度函数指针)(double, double, double)) {
    double 临时伤害总和变量 = 0;
    double 时间变量 = 0;
    double X坐标变量 = 0;
    double Y坐标变量 = 0;
    double 概率积分临时变量;
    屏幕偏差 后坐力偏差临时变量;
    int 循环时间变量dt;
    int 循环X坐标变量dx;
    int 循环Y坐标变量dy;
    for (循环时间变量dt = 0; 循环时间变量dt < 1000; 循环时间变量dt++) {
        时间变量 = (double)循环时间变量dt / 1000;
        后坐力偏差临时变量 = p2020后坐力函数(时间变量);//后坐力函数最后会进人枪械集合 作为其中一个元素
        概率积分临时变量 = 0;
        for (循环Y坐标变量dy = 0; 循环Y坐标变量dy < 100; 循环Y坐标变量dy++) {
            for (循环X坐标变量dx = 0; 循环X坐标变量dx < 100; 循环X坐标变量dx++) {
                概率积分临时变量 = 概率积分临时变量 + 概率密度函数指针(后坐力偏差临时变量.X_屏幕 - 0.5 + ((double)循环X坐标变量dx / 100), 后坐力偏差临时变量.Y_屏幕 - 0.5 + ((double)循环Y坐标变量dy / 100), 1) / 10000;
            }
        }
        临时伤害总和变量 = 临时伤害总和变量 + 概率积分临时变量 / 1000;
        printf("总伤害 %lf 准星X %lf 准星Y %lf 时间 %lf\n", 临时伤害总和变量, 后坐力偏差临时变量.X_屏幕, 后坐力偏差临时变量.Y_屏幕, 时间变量);
    }
    临时伤害总和变量 = 临时伤害总和变量 * 枪械实体.武器伤害 * 枪械实体.武器射速;
    return 临时伤害总和变量;
};

double 一般模型累计概率形(枪械 枪械实体, 目标总体 目标实体,int 运算精度) {//无压枪 目标无位移 
    double 临时伤害总和变量 = 0;
    double 时间变量 = 0;
    double 命中概率 = 0;
    int 循环变量;
    目标中心实际位置 临时目标位置变量 = 目标实体.目标游戏内起始位置;
    for (循环变量 = 0; 循环变量 < 枪械实体.耗光时间 * 运算精度; 循环变量++) {
        时间变量 = (double)循环变量 / (double)运算精度;
        临时目标位置变量 = 目标实体.目标游戏内移动函数指针(时间变量, 目标实体.目标游戏内起始位置);
        目标实体.目标在屏幕位置 = 实际位置函数(目标实体.目标游戏内起始位置, 目标实体.目标游戏内移动函数指针, 目标实体.目标游戏内大小函数指针,枪械实体.后坐力函数指针, 时间变量);
        命中概率 = 枪械实体.子弹概率累计函数指针(目标实体.目标在屏幕位置.右上角_X_屏幕, 目标实体.目标在屏幕位置.右上角_Y_屏幕, 枪械实体.子弹散布参数) - 枪械实体.子弹概率累计函数指针(目标实体.目标在屏幕位置.右上角_X_屏幕, 目标实体.目标在屏幕位置.左下角_Y_屏幕, 枪械实体.子弹散布参数) - 枪械实体.子弹概率累计函数指针(目标实体.目标在屏幕位置.左下角_X_屏幕, 目标实体.目标在屏幕位置.右上角_Y_屏幕, 枪械实体.子弹散布参数) + 枪械实体.子弹概率累计函数指针(目标实体.目标在屏幕位置.左下角_X_屏幕, 目标实体.目标在屏幕位置.左下角_Y_屏幕, 枪械实体.子弹散布参数);
        临时伤害总和变量 = 临时伤害总和变量 + 命中概率 * 枪械实体.武器伤害 * 枪械实体.武器射速 * 枪械实体.子弹衰减函数指针(临时目标位置变量.Z_实际)/ (double)运算精度;
        printf("总伤害 %lf 右上角X_屏幕 %lf 右上角Y_屏幕 %lf 左下角X_屏幕 %lf 左下角Y_屏幕 %lf 时间 %lf\n", 临时伤害总和变量, 目标实体.目标在屏幕位置.右上角_X_屏幕, 目标实体.目标在屏幕位置.右上角_Y_屏幕, 目标实体.目标在屏幕位置.左下角_X_屏幕, 目标实体.目标在屏幕位置.左下角_Y_屏幕, 时间变量);
    }
    return 临时伤害总和变量;
};

double 复杂模型累计概率形(枪械 枪械实体, 目标总体 目标实体,玩家技术 玩家实体, int 运算精度) {//无压枪 目标无位移 
    double 临时伤害总和变量 = 0;
    double 时间变量 = 0;
    double 命中概率 = 0;
    int 循环变量;
    屏幕拐点序列 压枪[100];
    屏幕拐点序列 跟枪[500];
    屏幕拐点序列* 后座序列 = 枪械实体.枪械子弹序列;
    屏幕拐点序列* 压枪序列=压枪;
    实际拐点序列* 移动序列 = 目标实体.移动序列;
    屏幕偏差 移动屏幕序列;
    屏幕拐点序列* 跟枪序列=跟枪;
    边框实际位置 目标边框位置;

    屏幕拐点位置_转速度函数(后座序列);
    压枪函数(玩家实体, 后座序列, 压枪序列);
    实际拐点位置_转速度函数(移动序列);
    跟枪函数(后座序列, 压枪序列, 移动序列, 玩家实体, 跟枪序列);
    for (循环变量 = 0; 循环变量 < 枪械实体.耗光时间 * 运算精度; 循环变量++) {
        时间变量 = (double)循环变量 / (double)运算精度;
        目标边框位置 = 实际位置函数(后座序列, 压枪序列, 移动序列, 跟枪序列, 目标实体.目标游戏内大小序列,时间变量);
        命中概率= 枪械实体.子弹概率累计函数指针(目标边框位置.右上角_X_屏幕, 目标边框位置.右上角_Y_屏幕, 枪械实体.子弹散布参数) - 枪械实体.子弹概率累计函数指针(目标边框位置.右上角_X_屏幕, 目标边框位置.左下角_Y_屏幕, 枪械实体.子弹散布参数) - 枪械实体.子弹概率累计函数指针(目标边框位置.左下角_X_屏幕, 目标边框位置.右上角_Y_屏幕, 枪械实体.子弹散布参数) + 枪械实体.子弹概率累计函数指针(目标边框位置.左下角_X_屏幕, 目标边框位置.左下角_Y_屏幕, 枪械实体.子弹散布参数);
        临时伤害总和变量 = 临时伤害总和变量 + 命中概率 * 枪械实体.武器伤害 * 枪械实体.武器射速 * 枪械实体.子弹衰减函数指针(实际拐点型_转实际位置函数(移动序列,时间变量).Z_实际) / (double)运算精度;
        printf("总伤害 %lf 右上角X_屏幕 %lf 右上角Y_屏幕 %lf 左下角X_屏幕 %lf 左下角Y_屏幕 %lf 时间 %lf\n", 临时伤害总和变量, 目标边框位置.右上角_X_屏幕, 目标边框位置.右上角_Y_屏幕, 目标边框位置.左下角_X_屏幕, 目标边框位置.左下角_Y_屏幕, 时间变量);
    }
    return 临时伤害总和变量;
};
void 目标运动绘制函数(实际拐点序列* 目标移动, double Time, Mat& frame, double NowX, double NowY, double X, double Y, double Z);
void 显示函数(屏幕拐点序列* 后坐力拐点, 屏幕拐点序列* 压枪拐点, 实际拐点序列* 目标移动, 屏幕拐点序列* 跟枪拐点)
{
    // 创建窗口
    int i;
    int j;
    for (i = 0; 后坐力拐点[i + 1].开火时间_T != 0; i++) {
    }
    cout << i;
    namedWindow("Animation", WINDOW_NORMAL);

    // 设置动画帧率
    int fps = 144;
    int delay = 1000 / fps;

    // 计算动画总时长
    double totalTime = 后坐力拐点[i].开火时间_T - 后坐力拐点[0].开火时间_T;

    // 记录动画开始时间
    auto start = high_resolution_clock::now();

    // 循环播放动画
    while (true)
    {
        double x, y;
        x = 0; y = 0;
        // 计算当前时间点
        auto now = high_resolution_clock::now();
        double elapsed = duration_cast<duration<double>>(now - start).count();
        double Time = fmod(elapsed, totalTime);// a/b的余数
        // 清空画布
        Mat frame(X宽度, Y长度, CV_8UC3, Scalar(255, 255, 255));
        //绘制准星
        line(frame, Point(X宽度 / 2, Y长度 / 2 - 20), Point(X宽度 / 2, Y长度 / 2 + 20), Scalar(0, 0, 0), 2, LINE_AA);
        line(frame, Point(X宽度 / 2 - 20, Y长度 / 2), Point(X宽度 / 2 + 20, Y长度 / 2), Scalar(0, 0, 0), 2, LINE_AA);

        // 计算当前点位置
        屏幕偏差 后坐力偏差 = 屏幕拐点型_转屏幕偏差函数(后坐力拐点, Time);
        屏幕偏差 压枪偏差 = 屏幕拐点型_转屏幕偏差函数(压枪拐点, Time);
        目标中心实际位置 目标移动位置 = 实际拐点型_转实际位置函数(目标移动, Time);
        屏幕偏差 跟枪偏差 = 屏幕拐点型_转屏幕偏差函数(跟枪拐点, Time);
        //计算现在点距离开始点坐标
        x = 后坐力偏差.X_屏幕 * (-1) + 压枪偏差.X_屏幕 - 跟枪偏差.X_屏幕;
        y = 后坐力偏差.Y_屏幕 * (-1) + 压枪偏差.Y_屏幕 - 跟枪偏差.Y_屏幕;
        // 绘制后坐力直线
        for (j = 0; 后坐力拐点[j + 1].开火时间_T < Time; j++) {
            line(frame, Point((后坐力拐点[j].位置_X_屏幕 + x) * (-1) + X宽度 / 2, (后坐力拐点[j].位置_Y_屏幕 + y) * (-1) + Y长度 / 2), Point((后坐力拐点[j+1].位置_X_屏幕 + x) * (-1) + X宽度 / 2, (后坐力拐点[j+1].位置_Y_屏幕 + y) * (-1) + Y长度 / 2), Scalar(0, 0, 0), 2, LINE_AA);
        }
        line(frame, Point((后坐力拐点[j].位置_X_屏幕 + x) * (-1) + X宽度 / 2, (后坐力拐点[j].位置_Y_屏幕 + y) * (-1) + Y长度 / 2), Point((后坐力偏差.X_屏幕 + x) * (-1) + X宽度 / 2, (后坐力偏差.Y_屏幕 + y) * (-1) + Y长度 / 2), Scalar(0, 0, 0), 2, LINE_AA);
        //绘制压枪曲线
        for (j = 0; 压枪拐点[j + 1].开火时间_T < Time; j++) {
            line(frame, Point((压枪拐点[j].位置_X_屏幕 - 跟枪偏差.X_屏幕) * (-1) + X宽度 / 2, (压枪拐点[j].位置_Y_屏幕 - 跟枪偏差.Y_屏幕) * (-1) + Y长度 / 2), Point((压枪拐点[j + 1].位置_X_屏幕 - 跟枪偏差.X_屏幕) * (-1) + X宽度 / 2, (压枪拐点[j + 1].位置_Y_屏幕 - 跟枪偏差.Y_屏幕) * (-1) + Y长度 / 2), Scalar(0, 0, 255), 2, LINE_AA);
        }
        line(frame, Point((压枪拐点[j].位置_X_屏幕 - 跟枪偏差.X_屏幕) * (-1) + X宽度 / 2, (压枪拐点[j].位置_Y_屏幕 - 跟枪偏差.Y_屏幕) * (-1) + Y长度 / 2), Point((压枪偏差.X_屏幕 - 跟枪偏差.X_屏幕) * (-1) + X宽度 / 2, (压枪偏差.Y_屏幕 - 跟枪偏差.Y_屏幕) * (-1) + Y长度 / 2), Scalar(0, 0, 255), 2, LINE_AA);
        //绘制移动近似曲线
        目标运动绘制函数(目标移动, Time, frame, x, y, 目标移动位置.X_实际, 目标移动位置.Y_实际, 目标移动位置.Z_实际);
        //绘制跟枪曲线
        for (j = 0; 跟枪拐点[j + 1].开火时间_T < Time; j++) {
            line(frame, Point((跟枪拐点[j].位置_X_屏幕 - 跟枪偏差.X_屏幕) * (-1) + X宽度 / 2, (跟枪拐点[j].位置_Y_屏幕 - 跟枪偏差.Y_屏幕) * (-1) + Y长度 / 2), Point((跟枪拐点[j + 1].位置_X_屏幕 - 跟枪偏差.X_屏幕) * (-1) + X宽度 / 2, (跟枪拐点[j + 1].位置_Y_屏幕 - 跟枪偏差.Y_屏幕) * (-1) + Y长度 / 2), Scalar(255, 0, 0), 2, LINE_AA);
        }
        line(frame, Point((跟枪拐点[j].位置_X_屏幕 - 跟枪偏差.X_屏幕) * (-1) + X宽度 / 2, (跟枪拐点[j].位置_Y_屏幕 - 跟枪偏差.Y_屏幕) * (-1) + Y长度 / 2), Point((跟枪偏差.X_屏幕  - 跟枪偏差.X_屏幕) * (-1) + X宽度 / 2, (跟枪偏差.Y_屏幕  - 跟枪偏差.Y_屏幕) * (-1) + Y长度 / 2), Scalar(255, 0, 0), 2, LINE_AA);

        // 显示画面
        imshow("Animation", frame);

        // 等待一段时间
        if (waitKey(delay) == 27) break;
    }
    return ;
};

void 目标运动绘制函数(实际拐点序列* 目标移动, double Time, Mat& frame, double NowX, double NowY, double X, double Y, double Z) {
    int j;
    for (j = 0; 目标移动[j + 1].转折时间_T < Time; j++) {
        line(frame, Point((目标移动[j].位置_X_实际 * FSXS / 目标移动[j].位置_Z_实际 + NowX) * (-1) + X宽度 / 2, (目标移动[j].位置_Y_实际 * FSXS / 目标移动[j].位置_Z_实际 + NowY) * (-1) + Y长度 / 2), Point((目标移动[j + 1].位置_X_实际 * FSXS / 目标移动[j+1].位置_Z_实际 + NowX) * (-1) + X宽度 / 2, (目标移动[j + 1].位置_Y_实际 * FSXS / 目标移动[j + 1].位置_Z_实际 + NowY) * (-1) + Y长度 / 2), Scalar(0, 255, 0), 2, LINE_AA);
    }
    line(frame, Point((目标移动[j].位置_X_实际 * FSXS / 目标移动[j].位置_Z_实际 + NowX) * (-1) + X宽度 / 2, (目标移动[j].位置_Y_实际 * FSXS / 目标移动[j].位置_Z_实际 + NowY) * (-1) + Y长度 / 2), Point((X * FSXS / Z + NowX) * (-1) + X宽度 / 2, (Y * FSXS / Z + NowY) * (-1) + Y长度 / 2), Scalar(0, 255, 0), 2, LINE_AA);
    return;
}
int main()
{
    srand(time(nullptr));
    枪械 p2020;
    目标总体 直布罗陀;
    玩家技术 你;
    int i = 0;
    char 结束字符;
    {
        p2020.武器伤害 = 18;
        p2020.武器射速 = 7;
        p2020.耗光时间 = 3.7;
        p2020.后坐力函数指针 = p2020后坐力函数;
        p2020.子弹散布参数 = 2;//数字越大越准
        p2020.子弹概率累计函数指针 = 子弹散布正态分布累计概率密度;
        p2020.子弹衰减函数指针 = p2020子弹衰减;
        p2020.枪械子弹序列[0] = { 0,0,0 };
        p2020.枪械子弹序列[1] = { 22,87,0.566 };
        p2020.枪械子弹序列[2] = { -8,140,0.866 };
        p2020.枪械子弹序列[3] = { 58,257,2.1 };
        p2020.枪械子弹序列[4] = { 19,305,3.06 };
        p2020.枪械子弹序列[5] = { 28,314,3.16 };
        p2020.枪械子弹序列[6] = { 6,332,3.7 };
    }
    {
        直布罗陀.目标血量 = 150;
        直布罗陀.目标游戏内起始位置 = { 0,0,10 };
        直布罗陀.目标游戏内起始大小 = { 10,10 };
        直布罗陀.目标游戏内大小函数指针 = 目标大小变动;
        直布罗陀.目标游戏内移动函数指针 = 目标移动;
        直布罗陀.移动序列[0] = { 0,0,10,0 };
        直布罗陀.移动序列[1] = { -100,100,10,0.5 };
        直布罗陀.移动序列[2] = { 200,200,11,1.0 };
        直布罗陀.移动序列[3] = { -300,300,12,1.5 };
        直布罗陀.移动序列[4] = { 400,400,13,2.0 };
        直布罗陀.移动序列[5] = { -500,500,14,2.5 };
        直布罗陀.移动序列[6] = { 600,600,15,3.0 };
        直布罗陀.移动序列[7] = { -700,700,15,3.5 };
        直布罗陀.移动序列[8] = { 800,800,15,4.0 };
        直布罗陀.目标游戏内大小序列[0] = { 100,100,0 };
        直布罗陀.目标游戏内大小序列[1] = { 100,100,10 };
    }
    {
        你.压枪方向熟练程度 = 10;
        你.压枪时间熟练程度 = 10;
        你.压枪速度熟练程度 = 10;
        你.反应力 = 0.1;
        你.简单压枪倍率 = 1;
        你.简单目标跟踪倍率 = 1;
        你.跟枪方向熟练程度 = 5;
        你.跟枪速度熟练程度 = 5;
        你.跟枪等级 = 1;
    }
    屏幕拐点序列* 后座序列;
    屏幕拐点序列 压枪序列[100];
    实际拐点序列* 移动序列;
    屏幕偏差 移动屏幕;
    屏幕拐点序列 跟枪序列[400];
    边框实际位置 边框位置;
    后座序列 = p2020.枪械子弹序列;
    屏幕拐点位置_转速度函数(后座序列);
    压枪函数(你, 后座序列, 压枪序列);
    移动序列 = 直布罗陀.移动序列;
    实际拐点位置_转速度函数(移动序列);
    跟枪函数(后座序列, 压枪序列, 移动序列, 你, 跟枪序列);
    double 总伤害 = 复杂模型累计概率形(p2020, 直布罗陀, 你, 1000);
    cout << 总伤害;
    显示函数(后座序列, 压枪序列, 移动序列, 跟枪序列);
}